(defpackage cl4l-iter
  (:export iter-next iter-result iter-yield with-iter)
  (:shadowing-import-from cl4l-utils symbol! with-symbols)
  (:shadowing-import-from cl-cont lambda/cc)
  (:use cl cl4l-test))

(in-package cl4l-iter)

(defmacro iter-yield (&optional result)
  ;; Signals ITER-yield with RESULT
  `(restart-case 
       (signal 'iter-yield :result ,result)
     (iter-next ())))

(defmacro with-iter ((name expr) &body body)
  ;; Executes BODY with EXPR bound to optional NAME,
  ;; hard coded synonyms are provided for anonymous use.
  `(let ((,name ,expr))
        
  
  ))

(define-test (:cont-iter :cond)
  (flet ((foo (max)
           (dotimes (i max)
             (iter-yield i))))
    (let ((j 0))
      (with-iter nil (foo test-max)
        (assert (= j iter-result))
        (incf j)
        (iter-next)))))

(define-test (:cont-iter :list)
  (flet ((foo (max)
           (let ((res))
             (dotimes (i max)
               (push i res))
             (nreverse res))))
    (let ((res (foo test-max)))
      (dotimes (j test-max)
        (assert (= (pop res) j))))))
